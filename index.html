<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Unsplash-cowry</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
      /* General styles */
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
      }
      .top {
        background-color: #dde3ea;
        padding: 80px;
      }

      .searching-text h1 {
        padding: 0;
        margin: 0;
        margin-left: 40px;
      }
      /* Search Bar Styles */
      .search-bar {
        display: flex;
        justify-content: center;
        padding: 40px;
        position: relative;
        z-index: 10; /* Ensures the search bar stays above the images */
      }
      .search-bar input {
        width: 100%;
        padding: 20px;
        font-size: 20px;
        border: none;
        border-radius: 4px;
        background-color: #fff;
      }
      .search-bar button {
        display: none;
      }

      /* Grid Styles */
      .image-grid {
        position: relative;
        top: -25px;
        display: grid;
        grid-template-columns: repeat(3, 1fr); /* Fixed 3 columns */
        gap: 40px;
        padding: 0 250px;
        margin-bottom: 20px;
        z-index: 999;
      }

      .image-container {
        position: relative;
        overflow: hidden;
        height: min-content;
        border-radius: 8px;
      }

      .image-container img {
        width: 100%;
        height: auto;
        border-radius: 8px;
        display: block;
        cursor: pointer;
      }

      .overlay {
        position: absolute;
        bottom: 0; /* Align to the bottom */
        left: 0;
        right: 0;
        text-align: start;
        color: #fff; /* Text color */
        padding: 10px; /* Add padding for spacing */
        box-sizing: border-box; /* Ensure padding doesn't affect width */

        /* Gradient background */
        background: linear-gradient(
          to bottom,
          rgba(0, 0, 0, 0) 0%,
          rgba(0, 0, 0, 0.8) 100%
        );
        opacity: 0.9; /* Control opacity */
      }
      .overlay h3 {
        font-size: 16px;
        margin: 0;
      }
      .overlay p {
        font-size: 12px;
        position: relative;
        left: -4px;
        margin: 0.5em;
      }

      .image-container:hover .overlay {
        opacity: 1; /* Show overlay on hover */
      }

      /* Modal Styles */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        border-radius: 8px;
        align-items: center;
        z-index: 1000;
      }
      .modalImage {
        border-radius: 8px;
      }

      .modal-content {
        border-radius: 8px;
        max-width: 600px;
        width: 100%;
        margin-top: 20px;
        padding: 0;

        background-color: #fff;
        position: relative; /* Make it relative for positioning overlay */
      }

      .modal img {
        max-width: 100%;
        height: 60%;
        background-color: #fff;
        border-radius: 8px 8px 0 0;
      }

      /* Image Info Overlay in Modal */
      .modal-overlay {
        margin-top: 20px;
        background-color: #fff;
      }

      .modal-overlay h3 {
        color: #3e4d64;
        padding: 0px 20px;
        margin: 0.25em;
      }
      .modal-overlay p {
        margin: 0.25em;
        margin-top: 0.5em;
        margin-bottom: 2em;
        color: #bec2c4;
        padding: 0px 20px;
        font-size: 12px;
      }

      /* Skeleton Loader Styles */
      .skeleton {
        background-color: #ddd;
        border-radius: 8px;
        margin-bottom: 20px;
        position: relative;
      }

      .skeleton-image {
        width: 100%;
        height: 200px;
        background-color: #e0e0e0;
        border-radius: 8px;
      }

      .skeleton-text {
        height: 16px;
        background-color: #ccc;
        margin-top: 10px;
        border-radius: 4px;
      }

      .skeleton-author {
        width: 50%;
      }

      .skeleton-location {
        width: 70%;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <script type="text/javascript">
      const app = Vue.createApp({
        data() {
          return {
            images: [],
            isLoading: true,
            error: null,
            modalImage: null, // Holds the data of the clicked image
            page: 1,
            perPage: 6,
            query: "", // Holds the search query
            isFetching: false, // Prevents multiple fetch requests
            searching: false, // Flag for search in progress
            searchCompleted: false, // Flag to show search completion
          };
        },
        methods: {
          async fetchImages() {
            if (this.isFetching) return; // Prevent duplicate fetching
            this.isFetching = true; // Set fetching state to true
            this.isLoading = true; // Trigger loading state

            try {
              const url = this.query
                ? `https://api.unsplash.com/search/photos/?client_id=ruLlONT6ashgc3z7y0B_35EyFnpUqcfbu0sJW4D96y4&query=${this.query}&page=${this.page}&per_page=${this.perPage}`
                : `https://api.unsplash.com/photos/?client_id=ruLlONT6ashgc3z7y0B_35EyFnpUqcfbu0sJW4D96y4&page=${this.page}&per_page=${this.perPage}`;

              const response = await fetch(url);
              const data = this.query
                ? (await response.json()).results
                : await response.json();

              const newImages = data.map((item) => ({
                small: item.urls.small,
                full: item.urls.full,
                description: item.alt_description,
                author: item.user.name,
                location: item.location
                  ? item.location.name
                  : "Unknown Location",
              }));

              setTimeout(() => {
                this.images = [...this.images, ...newImages]; // Append new images
                this.page++; // Increment page for next fetch
                this.isLoading = false; // Stop loading after images are fetched
                this.isFetching = false;
              }, 1000); // 1-second delay
            } catch (error) {
              console.log("Error fetching images", error);
              this.error = "Fetching failed ...please try again later...";
              this.isLoading = false;
              this.isFetching = false;
            }
          },
          async searchImages() {
            if (this.isFetching) return; // Prevent duplicate fetching
            this.isFetching = true; // Set fetching state to true
            this.isLoading = true; // Trigger loading state
            this.page = 1; // Reset page for new search
            this.images = []; // Clear previous images
            this.searching = true; // Indicate that a search is in progress
            this.searchCompleted = false; // Reset search completed state

            try {
              const response = await fetch(
                `https://api.unsplash.com/search/photos/?client_id=ruLlONT6ashgc3z7y0B_35EyFnpUqcfbu0sJW4D96y4&query=${this.query}&page=${this.page}&per_page=${this.perPage}`
              );
              const data = await response.json();
              this.images = data.results.map((item) => ({
                small: item.urls.small,
                full: item.urls.full,
                description: item.alt_description,
                author: item.user.name,
                location: item.location
                  ? item.location.name
                  : "Unknown Location",
              }));

              // Simulate a delay before showing the results
              setTimeout(() => {
                this.isLoading = false; // Stop loading after images are fetched
                this.searching = false; // Indicate that the search is complete
                this.searchCompleted = true; // Mark that the search is completed
              }, 1000); // Adjust this delay as needed
            } catch (error) {
              console.log("Error fetching search results", error);
              this.error =
                "Fetching search results failed. Please try again later.";
              this.isLoading = false;
              this.isFetching = false;
              this.searching = false; // Reset searching state on error
            }
          },
          openModal(image) {
            this.modalImage = image;
          },
          closeModal() {
            this.modalImage = null;
          },
        },
        mounted() {
          this.fetchImages(); // Fetch initial images
        },
        template: `
          <div>

            <div class="top">  
          
            <div class="search-bar">
              <input
                v-model="query"
                type="text"
                placeholder="Search images..."
                @keydown.enter="searchImages"
              />
              <button @click="searchImages">Search</button>
            </div>
<div class=searching-text>
         <!-- Display Searching Text -->
<h1 v-if="searching">Searching for "{{ query }}"</h1>

<!-- Display Search Results Header -->
<h1 v-if="!searching && query && searchCompleted">Search Results for "{{ query }}"</h1>
</div>

            </div>

            <!-- Display Images -->
            <div class="image-grid">
        <!-- Show skeleton loaders based on perPage -->
        <div v-if="isLoading" v-for="n in perPage" :key="n" class="skeleton">
            <div class="skeleton-image"></div>
            <div class="skeleton-text skeleton-author"></div>
            <div class="skeleton-text skeleton-location"></div>
        </div>

        <div v-if="error" class="error">{{ error }}</div>
        <div
            v-for="image in images"
            :key="image.small"
            class="image-container"
            @click="openModal(image)"
        >

            <img :src="image.small" :alt="image.description" />
            <div class="overlay">
                <h3>{{ image.author }}</h3>
                <p>{{ image.location }}</p>
            </div>
        </div>
    </div>

            <!-- Modal for Full-Size Image -->
            <div v-if="modalImage" class="modal" @click="closeModal">
              <div class="modal-content">
                <img :src="modalImage.full" alt="Full Image" />
                <div class="modal-overlay">
                  <h3>{{ modalImage.author }}</h3>
                  <p>{{ modalImage.location }}</p>
                  <p>{{ modalImage.description }}</p>
                </div>
              </div>
            </div>
          </div>
        `,
      });

      app.mount("#app");
    </script>
  </body>
</html>
