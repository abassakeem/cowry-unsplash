<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Unsplash-cowry</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
      /* Modal Styles */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      .modal-content {
        background-color: #fff;
        padding: 20px;
        border-radius: 8px;
        max-width: 600px;
        width: 100%;
        text-align: center;
      }
      .modal img {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
      }
      .close-btn {
        background-color: red;
        color: white;
        padding: 10px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script type="text/javascript">
      const app = Vue.createApp({
        data() {
          return {
            images: [],
            isLoading: false,
            error: null,
            modalImage: null, // Holds the data of the clicked image
            page: 1,
            perPage: 6,
            query: '', // Holds the search query
            isFetching: false, // Prevents multiple fetch requests
          };
        },
        methods: {
          async fetchImages() {
            if (this.isFetching) return; // Prevent duplicate fetching
            this.isFetching = true; // Set fetching state to true
            this.isLoading = true;

            try {
              const url = this.query
                ? `https://api.unsplash.com/search/photos/?client_id=ruLlONT6ashgc3z7y0B_35EyFnpUqcfbu0sJW4D96y4&query=${this.query}&page=${this.page}&per_page=${this.perPage}`
                : `https://api.unsplash.com/photos/?client_id=ruLlONT6ashgc3z7y0B_35EyFnpUqcfbu0sJW4D96y4&page=${this.page}&per_page=${this.perPage}`;
              
              const response = await fetch(url);
              const data = this.query ? (await response.json()).results : await response.json();
              
              const newImages = data.map((item) => ({
                small: item.urls.small,
                full: item.urls.full,
                description: item.alt_description,
                author: item.user.name,
                location: item.location ? item.location.name : 'Unknown Location',
              }));
              
              this.images = [...this.images, ...newImages]; // Append new images
              this.page++; // Increment page for next fetch
              this.isLoading = false;
              this.isFetching = false;
            } catch (error) {
              console.log("Error fetching images", error);
              this.error = "Fetching failed ...please try again later...";
              this.isLoading = false;
              this.isFetching = false;
            }
          },
          openModal(image) {
            this.modalImage = image; // Set the clicked image's data to modalImage
          },
          closeModal() {
            this.modalImage = null; // Clear the modalImage to close the modal
          },
          handleScroll() {
            const scrollHeight = document.documentElement.scrollHeight;
            const scrollTop = document.documentElement.scrollTop;
            const clientHeight = document.documentElement.clientHeight;
            
            if (scrollTop + clientHeight >= scrollHeight - 10) {
              // If scrolled to the bottom, fetch more images
              this.fetchImages();
            }
          },
        },
        mounted() {
          // Initial fetch of images
          this.fetchImages();
          
          // Add scroll event listener
          window.addEventListener('scroll', this.handleScroll);
        },
        unmounted() {
          // Clean up event listener when component is destroyed
          window.removeEventListener('scroll', this.handleScroll);
        },
        template: `
          <div>
            <h1>Unsplash</h1>
            <input
              v-model="query"
              @keyup.enter="fetchImages"
              type="text"
              placeholder="Search for images..."
              style="margin-bottom: 20px; padding: 8px; width: 300px;"
            />
            <button @click="fetchImages" style="padding: 8px; margin-left: 10px;">Search</button>
            
            <div v-if="isLoading && images.length === 0">Loading...</div>
            <div v-if="error">{{ error }}</div>
            <div v-else>
              <div v-for="image in images" :key="image.full" style="margin-bottom: 20px;">
                <img :src="image.small" :alt="image.description" style="max-width: 100%; height: auto; cursor: pointer;" @click="openModal(image)" />
                <p><strong>Author:</strong> {{ image.author }}</p>
                <p><strong>Location:</strong> {{ image.location }}</p>
              </div>
            </div>

            <!-- Modal -->
            <div v-if="modalImage" class="modal" @click.self="closeModal">
              <div class="modal-content">
                <img :src="modalImage.full" :alt="modalImage.description" />
                <p><strong>Author:</strong> {{ modalImage.author }}</p>
                <p><strong>Description:</strong> {{ modalImage.description || 'No description available' }}</p>
                <button class="close-btn" @click="closeModal">Close</button>
              </div>
            </div>

            <div v-if="isLoading && images.length > 0">Loading more images...</div>
          </div>
        `,
      });
      app.mount("#app");
    </script>
  </body>
</html>
